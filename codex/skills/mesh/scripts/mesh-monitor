#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=mesh-lib.sh
source "${SCRIPT_DIR}/mesh-lib.sh"

usage() {
  cat <<'USAGE'
Usage: mesh-monitor [GLOBAL_FLAGS] [options] [agent-name...]

Inspect mesh agent hooks, liveness, and workspace presence.

Options:
  --count N           Agent count when names are not provided (default: MESH_CONCURRENCY or 6)
  --prefix NAME-      Agent name prefix (default: mesh-)
  --start N           Agent name start index (default: 1)
  --watch SECONDS     Poll continuously (disallowed with --json)
  --allow-stale       Pass --allow-stale to mesh-bd-ro
  --last-interaction  Show last interaction timestamp (requires rg)

Config:
  MESH_WORKSPACE_ROOT Workspace root (default: ../workspaces/<repo>)

Global flags:
  -h, --help     Show help and exit
  --dry-run      Print intended actions without executing
  --json         Emit machine-readable JSON output (single object)
USAGE
}

mesh_require_cmd bd
mesh_require_cmd jq

mesh_parse_common_flags "$@"

if [[ ${MESH_HELP} -eq 1 ]]; then
  usage
  exit 0
fi

count="${MESH_CONCURRENCY:-6}"
prefix="${MESH_AGENT_PREFIX:-mesh-}"
start="${MESH_AGENT_START:-1}"
watch=""
allow_stale=0
show_last_interaction=0
names=()

usage_error() {
  echo "error: $*" >&2
  usage >&2
  exit 2
}

idx=0
while [[ ${idx} -lt ${#MESH_ARGS[@]} ]]; do
  arg="${MESH_ARGS[${idx}]}"
  case "${arg}" in
    --count)
      if [[ $((idx + 1)) -ge ${#MESH_ARGS[@]} ]]; then
        usage_error "mesh-monitor: --count requires a value"
      fi
      count="${MESH_ARGS[$((idx + 1))]}"
      idx=$((idx + 2))
      ;;
    --prefix)
      if [[ $((idx + 1)) -ge ${#MESH_ARGS[@]} ]]; then
        usage_error "mesh-monitor: --prefix requires a value"
      fi
      prefix="${MESH_ARGS[$((idx + 1))]}"
      idx=$((idx + 2))
      ;;
    --start)
      if [[ $((idx + 1)) -ge ${#MESH_ARGS[@]} ]]; then
        usage_error "mesh-monitor: --start requires a value"
      fi
      start="${MESH_ARGS[$((idx + 1))]}"
      idx=$((idx + 2))
      ;;
    --watch)
      if [[ $((idx + 1)) -ge ${#MESH_ARGS[@]} ]]; then
        usage_error "mesh-monitor: --watch requires a value"
      fi
      watch="${MESH_ARGS[$((idx + 1))]}"
      idx=$((idx + 2))
      ;;
    --allow-stale)
      allow_stale=1
      idx=$((idx + 1))
      ;;
    --last-interaction)
      show_last_interaction=1
      idx=$((idx + 1))
      ;;
    --)
      idx=$((idx + 1))
      while [[ ${idx} -lt ${#MESH_ARGS[@]} ]]; do
        names+=("${MESH_ARGS[${idx}]}")
        idx=$((idx + 1))
      done
      ;;
    -*)
      usage_error "mesh-monitor: unknown flag: ${arg}"
      ;;
    *)
      names+=("${arg}")
      idx=$((idx + 1))
      ;;
  esac
done

if [[ -n "${watch}" && ${MESH_JSON} -eq 1 ]]; then
  usage_error "mesh-monitor: --watch cannot be combined with --json"
fi

if [[ -n "${watch}" && ! "${watch}" =~ ^[0-9]+$ ]]; then
  usage_error "mesh-monitor: --watch must be an integer number of seconds"
fi
if ! [[ "${count}" =~ ^[0-9]+$ ]]; then
  usage_error "mesh-monitor: --count must be an integer"
fi
if ! [[ "${start}" =~ ^[0-9]+$ ]]; then
  usage_error "mesh-monitor: --start must be an integer"
fi

mesh_agent_pool_script="${SCRIPT_DIR}/mesh-agent-pool"
mesh_bd_ro_script="${SCRIPT_DIR}/mesh-bd-ro"

mesh_repo_root() {
  local root
  root="$(git rev-parse --show-toplevel 2>/dev/null || true)"
  if [[ -z "${root}" ]]; then
    mesh_die "mesh-monitor: not inside a git repository"
  fi
  printf '%s' "${root}"
}

mesh_workspace_slug() {
  local raw="$1"
  raw="${raw##*/}"
  raw="$(printf '%s' "${raw}" | sed -E 's/^[.]+//; s/[^A-Za-z0-9._-]+/-/g; s/\.{2,}/-/g; s/[.]+$//; s/^-+//; s/-+$//')"
  if [[ "${raw}" == *.lock ]]; then
    raw="${raw%.lock}-lock"
  fi
  if [[ -z "${raw}" ]]; then
    mesh_die "mesh-monitor: invalid bead id: $1"
  fi
  printf '%s' "${raw}"
}

mesh_workspace_path() {
  local bead_id="$1"
  local root="${MESH_WORKSPACE_ROOT:-}"
  if [[ -z "${root}" ]]; then
    local repo_root
    repo_root="$(mesh_repo_root)"
    local repo_name
    repo_name="$(basename "${repo_root}")"
    root="${repo_root%/}/../workspaces/${repo_name}"
  fi
  root="${root%/}"
  local slug
  slug="$(mesh_workspace_slug "${bead_id}")"
  printf '%s/%s' "${root}" "${slug}"
}

mesh_epoch_from_iso() {
  local ts="$1"
  local clean
  clean="$(printf '%s' "${ts}" | sed -E 's/\.[0-9]+//; s/([+-][0-9]{2}):([0-9]{2})/\1\2/')"
  if date -u -j -f "%Y-%m-%dT%H:%M:%S%z" "${clean}" +%s 2>/dev/null; then
    return 0
  fi
  if date -u -d "${ts}" +%s 2>/dev/null; then
    return 0
  fi
  return 1
}

mesh_agent_process_state() {
  local token="$1"
  if ! command -v pgrep >/dev/null 2>&1; then
    printf '%s' "unknown"
    return 0
  fi
  if pgrep -f "codex.*${token}" >/dev/null 2>&1; then
    printf '%s' "running"
    return 0
  fi
  printf '%s' "none"
}

mesh_last_interaction() {
  local issue_id="$1"
  if [[ ${show_last_interaction} -ne 1 ]]; then
    printf '%s' ""
    return 0
  fi
  if ! command -v rg >/dev/null 2>&1; then
    printf '%s' "rg-missing"
    return 0
  fi
  local line
  line="$(rg "\"issue_id\":\"${issue_id}\"" .beads/interactions.jsonl | tail -n1 || true)"
  if [[ -z "${line}" ]]; then
    printf '%s' ""
    return 0
  fi
  local created
  created="$(sed -E 's/.*"created_at":"([^"]+)".*/\1/' <<<"${line}")"
  printf '%s' "${created}"
}

collect_names() {
  if [[ ${#names[@]} -gt 0 ]]; then
    printf '%s\n' "${names[@]}"
    return 0
  fi
  local i
  for ((i=0; i<count; i++)); do
    printf '%s\n' "${prefix}$((start + i))"
  done
}

emit_table() {
  printf '%-8s %-12s %-16s %-8s %-20s %-6s %-8s %-10s' \
    "Agent" "AgentID" "Hook" "State" "LastActivity" "Age" "Proc" "Workspace"
  if [[ ${show_last_interaction} -eq 1 ]]; then
    printf ' %-20s' "LastInteraction"
  fi
  printf '\n'
}

render_once() {
  local timestamp
  timestamp="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
  local -a rows=()
  local -a json_items=()

  while IFS= read -r name; do
    [[ -z "${name}" ]] && continue
    local agent_id=""
    agent_id="$("${mesh_agent_pool_script}" id "${name}" 2>/dev/null || true)"
    local hook_bead=""
    local agent_state=""
    local last_activity=""
    local age=""
    local proc_state=""
    local ws_path=""
    local ws_state=""
    local last_interaction=""

    if [[ -n "${agent_id}" ]]; then
      local ro_flags=()
      if [[ ${allow_stale} -eq 1 ]]; then
        ro_flags+=(--allow-stale)
      fi
      local agent_json=""
      if agent_json="$("${mesh_bd_ro_script}" "${ro_flags[@]}" --json show "${agent_id}" 2>/dev/null)"; then
        hook_bead="$(jq -r '.[0].hook_bead // empty' <<<"${agent_json}")"
        agent_state="$(jq -r '.[0].agent_state // empty' <<<"${agent_json}")"
        last_activity="$(jq -r '.[0].last_activity // empty' <<<"${agent_json}")"
      fi
    fi

    if [[ -n "${last_activity}" ]]; then
      local last_epoch=""
      if last_epoch="$(mesh_epoch_from_iso "${last_activity}")"; then
        local now_epoch
        now_epoch="$(date -u +%s)"
        age="$((now_epoch - last_epoch))"
      fi
    fi

    if [[ -n "${hook_bead}" ]]; then
      proc_state="$(mesh_agent_process_state "${hook_bead}")"
      ws_path="$(mesh_workspace_path "${hook_bead}")"
      if [[ -d "${ws_path}" ]]; then
        if [[ -d "${ws_path}/.jj" ]]; then
          ws_state="jj"
        elif [[ -d "${ws_path}/.git" ]]; then
          ws_state="git"
        else
          ws_state="dir"
        fi
      else
        ws_state="missing"
      fi
      last_interaction="$(mesh_last_interaction "${hook_bead}")"
    fi

    if [[ ${MESH_JSON} -eq 1 ]]; then
      json_items+=("$(jq -n \
        --arg agent_name "${name}" \
        --arg agent_id "${agent_id}" \
        --arg hook_bead "${hook_bead}" \
        --arg agent_state "${agent_state}" \
        --arg last_activity "${last_activity}" \
        --arg age_seconds "${age}" \
        --arg process "${proc_state}" \
        --arg workspace_path "${ws_path}" \
        --arg workspace_state "${ws_state}" \
        --arg last_interaction "${last_interaction}" \
        '{agent_name:$agent_name,agent_id:$agent_id,hook_bead:$hook_bead,agent_state:$agent_state,last_activity:$last_activity,age_seconds:$age_seconds,process:$process,workspace_path:$workspace_path,workspace_state:$workspace_state,last_interaction:$last_interaction}')")
    else
      rows+=("$(printf '%-8s %-12s %-16s %-8s %-20s %-6s %-8s %-10s' \
        "${name}" "${agent_id:-}" "${hook_bead:-}" "${agent_state:-}" "${last_activity:-}" "${age:-}" "${proc_state:-}" "${ws_state:-}")")
      if [[ ${show_last_interaction} -eq 1 ]]; then
        rows[-1]+="$(printf ' %-20s' "${last_interaction:-}")"
      fi
    fi
  done < <(collect_names)

  if [[ ${MESH_JSON} -eq 1 ]]; then
    if [[ ${#json_items[@]} -eq 0 ]]; then
      jq -n --arg timestamp "${timestamp}" '{ok:true,timestamp:$timestamp,agents:[]}'
      return 0
    fi
    printf '%s\n' "${json_items[@]}" | jq -s --arg timestamp "${timestamp}" '{ok:true,timestamp:$timestamp,agents:.}'
    return 0
  fi

  printf 'mesh-monitor: %s\n' "${timestamp}"
  emit_table
  local row
  for row in "${rows[@]}"; do
    printf '%s\n' "${row}"
  done
}

if [[ -z "${watch}" ]]; then
  render_once
  exit 0
fi

while true; do
  render_once
  sleep "${watch}"
  echo ""
done
