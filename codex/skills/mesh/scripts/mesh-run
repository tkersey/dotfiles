#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=mesh-lib.sh
# shellcheck disable=SC1091
source "${SCRIPT_DIR}/mesh-lib.sh"

usage() {
  cat <<'USAGE'
Usage: mesh-run [GLOBAL_FLAGS] <target> [options]

Orchestrate a mesh run for an epic or an existing mol-mesh-run molecule.

Target forms:
  <epic-id>         Epic bead id (e.g. gt-epic-123)
  <mol-id>          mol-mesh-run molecule id

Options:
  --concurrency N        Max agents per wave (required for new runs)
  --workspace-backend X  Override workspace backend (allowed: worktree)
  --audit-level X        Override audit level (allowed: full|minimal|none)

Config:
  MESH_AGENT_MODEL       Audit model label for agent prompts (default: gpt-5.2-codex)
  MESH_AGENT_PREFIX      Agent name prefix (default: mesh-)
  MESH_AGENT_START       Agent name start index (default: 1)
  MESH_STALE_HOOK_TTL_SECONDS  Clear agent hooks if idle beyond TTL (default: 3600)
  MESH_PREFLIGHT         Require workspace bd read to succeed before dispatch (default: 1)
  MESH_PREFLIGHT_SYNC    Run bd --sandbox sync --import-only before preflight (default: 1)
  MESH_WORKSPACE_ROOT    Workspace root (default: ../workspaces/<repo>)
  MESH_CX_EXEC           Override cx-exec.sh path
  MESH_RUN_LOG_DIR       Write agent stdout/stderr logs to this directory (per bead)

Global flags:
  -h, --help     Show help and exit
  --dry-run      Print intended bd commands without executing writes
  --json         Emit machine-readable JSON output (single object)
USAGE
}

mesh_require_cmd bd
mesh_require_cmd jq
mesh_require_cmd git

mesh_parse_common_flags "$@"

if [[ ${MESH_HELP} -eq 1 ]]; then
  usage
  exit 0
fi

concurrency="${MESH_CONCURRENCY:-}"
workspace_backend=""
audit_level=""
agent_model="${MESH_AGENT_MODEL:-gpt-5.2-codex}"
agent_prefix="${MESH_AGENT_PREFIX:-mesh-}"
agent_start="${MESH_AGENT_START:-1}"
stale_hook_ttl_seconds="${MESH_STALE_HOOK_TTL_SECONDS:-3600}"
mesh_preflight="${MESH_PREFLIGHT:-1}"
mesh_preflight_sync="${MESH_PREFLIGHT_SYNC:-1}"
mesh_run_log_dir="${MESH_RUN_LOG_DIR:-}"

mesh_workspace_script="${SCRIPT_DIR}/mesh-workspace"
mesh_audit_script="${SCRIPT_DIR}/mesh-audit"
mesh_gates_script="${SCRIPT_DIR}/mesh-gates"
mesh_merge_slot_script="${SCRIPT_DIR}/mesh-merge-slot"
mesh_agent_pool_script="${SCRIPT_DIR}/mesh-agent-pool"
mesh_bd_ro_hint="codex/skills/mesh/scripts/mesh-bd-ro"
cx_exec_script="${MESH_CX_EXEC:-${SCRIPT_DIR}/../../cx/scripts/cx-exec.sh}"

usage_error() {
  echo "error: $*" >&2
  usage >&2
  exit 2
}

if [[ ${#MESH_ARGS[@]} -eq 0 ]]; then
  usage_error "mesh-run: missing target"
fi

targets=()
idx=0
while [[ ${idx} -lt ${#MESH_ARGS[@]} ]]; do
  arg="${MESH_ARGS[${idx}]}"
  case "${arg}" in
    --concurrency)
      if [[ $((idx + 1)) -ge ${#MESH_ARGS[@]} ]]; then
        usage_error "mesh-run: --concurrency requires a value"
      fi
      concurrency="${MESH_ARGS[$((idx + 1))]}"
      idx=$((idx + 2))
      ;;
    --workspace-backend)
      if [[ $((idx + 1)) -ge ${#MESH_ARGS[@]} ]]; then
        usage_error "mesh-run: --workspace-backend requires a value"
      fi
      workspace_backend="${MESH_ARGS[$((idx + 1))]}"
      idx=$((idx + 2))
      ;;
    --audit-level)
      if [[ $((idx + 1)) -ge ${#MESH_ARGS[@]} ]]; then
        usage_error "mesh-run: --audit-level requires a value"
      fi
      audit_level="${MESH_ARGS[$((idx + 1))]}"
      idx=$((idx + 2))
      ;;
    --)
      idx=$((idx + 1))
      while [[ ${idx} -lt ${#MESH_ARGS[@]} ]]; do
        targets+=("${MESH_ARGS[${idx}]}")
        idx=$((idx + 1))
      done
      ;;
    -*)
      usage_error "mesh-run: unknown flag: ${arg}"
      ;;
    *)
      targets+=("${arg}")
      idx=$((idx + 1))
      ;;
  esac
done

if [[ ${#targets[@]} -ne 1 ]]; then
  usage_error "mesh-run: expected exactly one target (got ${#targets[@]})"
fi

target="${targets[0]}"

if [[ -n "${concurrency}" && ! "${concurrency}" =~ ^[0-9]+$ ]]; then
  usage_error "mesh-run: --concurrency must be an integer"
fi

declare -a DRY_RUN_COMMANDS=()

mesh_cmd_string() {
  local out=""
  local arg
  for arg in "$@"; do
    out+="${arg} "
  done
  printf '%s' "${out% }"
}

record_cmd() {
  DRY_RUN_COMMANDS+=("$(mesh_cmd_string "$@")")
}

run_read() {
  record_cmd "$@"
  "$@"
}

run_write() {
  record_cmd "$@"
  if [[ ${MESH_DRY_RUN} -eq 1 ]]; then
    return 0
  fi
  "$@"
}

run_write_status() {
  record_cmd "$@"
  if [[ ${MESH_DRY_RUN} -eq 1 ]]; then
    return 0
  fi
  set +e
  "$@"
  local status=$?
  set -e
  return "${status}"
}

run_write_in_dir() {
  local dir="$1"
  shift
  record_cmd bash -lc "cd \"${dir}\" && $(mesh_cmd_string "$@")"
  if [[ ${MESH_DRY_RUN} -eq 1 ]]; then
    return 0
  fi
  (cd "${dir}" && "$@")
}

run_write_in_dir_logged() {
  local dir="$1"
  local log_file="$2"
  shift 2
  record_cmd bash -lc "cd \"${dir}\" && $(mesh_cmd_string "$@") > \"${log_file}\" 2>&1"
  if [[ ${MESH_DRY_RUN} -eq 1 ]]; then
    return 0
  fi
  (cd "${dir}" && "$@") > "${log_file}" 2>&1
}

mesh_epoch_from_iso() {
  local ts="$1"
  local clean
  clean="$(printf '%s' "${ts}" | sed -E 's/\.[0-9]+//; s/([+-][0-9]{2}):([0-9]{2})/\1\2/')"
  if date -u -j -f "%Y-%m-%dT%H:%M:%S%z" "${clean}" +%s 2>/dev/null; then
    return 0
  fi
  if date -u -d "${ts}" +%s 2>/dev/null; then
    return 0
  fi
  return 1
}

mesh_agent_process_running() {
  local token="$1"
  if ! command -v pgrep >/dev/null 2>&1; then
    return 0
  fi
  if pgrep -f "codex.*${token}" >/dev/null 2>&1; then
    return 0
  fi
  return 1
}

mesh_cleanup_stale_hooks() {
  local ttl="$1"
  if [[ -z "${ttl}" ]]; then
    return 0
  fi
  if ! [[ "${ttl}" =~ ^[0-9]+$ ]]; then
    usage_error "mesh-run: MESH_STALE_HOOK_TTL_SECONDS must be an integer"
  fi
  if [[ "${ttl}" -le 0 ]]; then
    return 0
  fi

  local now
  now="$(date -u +%s)"
  local idx=0
  while [[ ${idx} -lt ${concurrency} ]]; do
    local agent_name="${agent_prefix}$((agent_start + idx))"
    local agent_id=""
    if ! agent_id="$("${mesh_agent_pool_script}" id "${agent_name}" 2>/dev/null)"; then
      idx=$((idx + 1))
      continue
    fi
    local agent_json=""
    if ! agent_json="$(bd show "${agent_id}" --json 2>/dev/null)"; then
      idx=$((idx + 1))
      continue
    fi
    local hook_bead=""
    hook_bead="$(jq -r '.[0].hook_bead // empty' <<<"${agent_json}")"
    if [[ -z "${hook_bead}" || "${hook_bead}" == "null" ]]; then
      idx=$((idx + 1))
      continue
    fi
    local last_activity=""
    last_activity="$(jq -r '.[0].last_activity // empty' <<<"${agent_json}")"
    if [[ -z "${last_activity}" || "${last_activity}" == "null" ]]; then
      idx=$((idx + 1))
      continue
    fi
    local last_epoch=""
    if ! last_epoch="$(mesh_epoch_from_iso "${last_activity}")"; then
      idx=$((idx + 1))
      continue
    fi
    local age=$((now - last_epoch))
    if [[ "${age}" -lt "${ttl}" ]]; then
      idx=$((idx + 1))
      continue
    fi
    if mesh_agent_process_running "${hook_bead}"; then
      idx=$((idx + 1))
      continue
    fi

    run_write "${mesh_agent_pool_script}" release "${agent_name}"
    idx=$((idx + 1))
  done
}

run_read_capture() {
  local __var="$1"
  shift
  record_cmd "$@"
  local output
  if output="$("$@")"; then
    printf -v "${__var}" '%s' "${output}"
    return 0
  fi
  return $?
}

run_write_capture() {
  local __var="$1"
  shift
  record_cmd "$@"
  if [[ ${MESH_DRY_RUN} -eq 1 ]]; then
    printf -v "${__var}" '%s' ""
    return 0
  fi
  local output
  if output="$("$@")"; then
    printf -v "${__var}" '%s' "${output}"
    return 0
  fi
  return $?
}

require_json_field() {
  local value="$1"
  local name="$2"
  if [[ -z "${value}" || "${value}" == "null" ]]; then
    mesh_die "mesh-run: missing ${name} in mol-mesh-run variables"
  fi
}

mesh_repo_root() {
  local root
  root="$(git rev-parse --show-toplevel 2>/dev/null || true)"
  if [[ -z "${root}" ]]; then
    mesh_die "mesh-run: not inside a git repository"
  fi
  printf '%s' "${root}"
}

mesh_formula_source_dir() {
  local source_root
  source_root="$(cd "${SCRIPT_DIR}/../../../../" && pwd)"
  printf '%s/.beads/formulas' "${source_root}"
}

mesh_seed_formula() {
  local repo_root="$1"
  local source_dir="$2"
  local name="$3"
  local source="${source_dir}/${name}.formula.json"
  local target_dir="${repo_root}/.beads/formulas"
  local target="${target_dir}/${name}.formula.json"

  if [[ ! -f "${source}" ]]; then
    mesh_die "mesh-run: missing formula template: ${source}"
  fi

  if [[ -f "${target}" ]] && cmp -s "${source}" "${target}"; then
    return 0
  fi

  run_write mkdir -p "${target_dir}"
  run_write cp -f "${source}" "${target}"
}

mesh_seed_formulas() {
  local repo_root
  repo_root="$(mesh_repo_root)"
  local source_dir
  source_dir="$(mesh_formula_source_dir)"

  mesh_seed_formula "${repo_root}" "${source_dir}" "mol-mesh-run"
  mesh_seed_formula "${repo_root}" "${source_dir}" "mol-mesh-arm"
}

mesh_workspace_slug() {
  local raw="$1"
  raw="${raw##*/}"
  raw="$(printf '%s' "${raw}" | sed -E 's/^[.]+//; s/[^A-Za-z0-9._-]+/-/g; s/\.{2,}/-/g; s/[.]+$//; s/^-+//; s/-+$//')"
  if [[ "${raw}" == *.lock ]]; then
    raw="${raw%.lock}-lock"
  fi
  if [[ -z "${raw}" ]]; then
    mesh_die "mesh-run: invalid bead id: $1"
  fi
  printf '%s' "${raw}"
}

mesh_workspace_path() {
  local bead_id="$1"
  local root="${MESH_WORKSPACE_ROOT:-}"
  if [[ -z "${root}" ]]; then
    local repo_root
    repo_root="$(mesh_repo_root)"
    local repo_name
    repo_name="$(basename "${repo_root}")"
    root="${repo_root%/}/../workspaces/${repo_name}"
  fi
  root="${root%/}"
  local slug
  slug="$(mesh_workspace_slug "${bead_id}")"
  printf '%s/%s' "${root}" "${slug}"
}

mesh_audit_tool() {
  local tool_name="$1"
  local input_json="$2"
  local output_json="$3"
  local exit_code="${4:-0}"

  if [[ "${audit_level}" == "none" ]]; then
    return 0
  fi

  local issue_id="${mesh_run_id:-${target_id}}"
  if [[ -z "${issue_id}" ]]; then
    return 0
  fi

  run_write "${mesh_audit_script}" tool \
    --issue-id "${issue_id}" \
    --tool-name "${tool_name}" \
    --exit-code "${exit_code}" \
    --input "${input_json}" \
    --output "${output_json}"
}

mesh_audit_prompt() {
  local issue_id="$1"
  local model="$2"
  local prompt_text="$3"

  if [[ "${audit_level}" != "full" ]]; then
    return 0
  fi

  if [[ -z "${issue_id}" ]]; then
    return 0
  fi

  run_write "${mesh_audit_script}" prompt \
    --issue-id "${issue_id}" \
    --model "${model}" \
    --prompt "${prompt_text}"
}

mesh_seed_formulas
run_write bd sync --import-only

target_kind=""
target_id=""
epic_id=""
mesh_run_id=""
ready_ids=()
active_ids=()
completed_ids=()
blocked_ids=()
candidate_lines=()
sorted_candidates=()
selected_ids=()

mol_json=""
is_mol=0
if run_read_capture mol_json bd --no-daemon mol show "${target}" --json 2>/dev/null; then
  formula="$(jq -r '.formula? // .mol?.formula? // .proto?.formula? // empty' <<<"${mol_json}")"
  if [[ -n "${formula}" && "${formula}" != "mol-mesh-run" ]]; then
    mesh_die "mesh-run: mol target is not mol-mesh-run (formula: ${formula})"
  fi
  if [[ "${formula}" == "mol-mesh-run" ]]; then
    is_mol=1
  fi
fi

if [[ ${is_mol} -eq 1 ]]; then
  mesh_run_id="${target}"
  target_id="$(jq -r '.vars.target_id? // .variables.target_id? // empty' <<<"${mol_json}")"
  target_kind="$(jq -r '.vars.target_kind? // .variables.target_kind? // empty' <<<"${mol_json}")"
  if [[ -z "${concurrency}" ]]; then
    concurrency="$(jq -r '.vars.concurrency? // .variables.concurrency? // empty' <<<"${mol_json}")"
  fi
  if [[ -z "${workspace_backend}" ]]; then
    workspace_backend="$(jq -r '.vars.workspace_backend? // .variables.workspace_backend? // empty' <<<"${mol_json}")"
  fi
  if [[ -z "${audit_level}" ]]; then
    audit_level="$(jq -r '.vars.audit_level? // .variables.audit_level? // empty' <<<"${mol_json}")"
  fi

  require_json_field "${target_id}" "target_id"
  require_json_field "${target_kind}" "target_kind"
else
  issue_json=""
  run_read_capture issue_json bd show "${target}" --json
  issue_type="$(jq -r '.[0].issue_type // empty' <<<"${issue_json}")"
  if [[ "${issue_type}" != "epic" ]]; then
    mesh_die "mesh-run: target must be an epic id or mol-mesh-run id"
  fi
  target_kind="epic"
  target_id="${target}"

  if [[ -z "${concurrency}" ]]; then
    mesh_die "mesh-run: --concurrency is required for new runs"
  fi

  if [[ -z "${workspace_backend}" ]]; then
    workspace_backend="worktree"
  fi
  if [[ -z "${audit_level}" ]]; then
    audit_level="full"
  fi

  swarm_out=""
  run_write_capture swarm_out bd swarm create "${target_id}" --json
  : "${swarm_out}"

  mol_args=(bd --no-daemon mol pour mol-mesh-run
    --var "target_id=${target_id}"
    --var "target_kind=${target_kind}"
    --var "concurrency=${concurrency}")
  if [[ -n "${workspace_backend}" ]]; then
    mol_args+=(--var "workspace_backend=${workspace_backend}")
  fi
  if [[ -n "${audit_level}" ]]; then
    mol_args+=(--var "audit_level=${audit_level}")
  fi

  if [[ ${MESH_DRY_RUN} -eq 1 ]]; then
    run_write "${mol_args[@]}"
  else
    run_write_capture mesh_run_id "${mol_args[@]}"
  fi
fi

if [[ -z "${concurrency}" ]]; then
  mesh_die "mesh-run: missing concurrency (pass --concurrency or set in mol)"
fi
if ! [[ "${concurrency}" =~ ^[0-9]+$ ]] || [[ "${concurrency}" -lt 1 ]]; then
  usage_error "mesh-run: concurrency must be a positive integer"
fi
if [[ -n "${stale_hook_ttl_seconds}" && ! "${stale_hook_ttl_seconds}" =~ ^[0-9]+$ ]]; then
  usage_error "mesh-run: MESH_STALE_HOOK_TTL_SECONDS must be an integer"
fi
if [[ -n "${workspace_backend}" && "${workspace_backend}" != "worktree" ]]; then
  usage_error "mesh-run: --workspace-backend must be 'worktree'"
fi
if [[ -n "${audit_level}" ]]; then
  case "${audit_level}" in
    full|minimal|none)
      ;;
    *)
      usage_error "mesh-run: --audit-level must be one of: full|minimal|none"
      ;;
  esac
fi

run_write "${mesh_gates_script}" discover
run_write "${mesh_gates_script}" check

swarm_json=""
run_read_capture swarm_json bd swarm status "${target_id}" --json
epic_id="$(jq -r '.epic_id // empty' <<<"${swarm_json}")"
require_json_field "${epic_id}" "epic_id"

list_json=""
run_read_capture list_json bd list --parent "${epic_id}" --json

ready_ids=()
while IFS= read -r line; do
  [[ -z "${line}" ]] && continue
  ready_ids+=("${line}")
done < <(jq -r '.ready[].id' <<<"${swarm_json}")

active_ids=()
while IFS= read -r line; do
  [[ -z "${line}" ]] && continue
  active_ids+=("${line}")
done < <(jq -r '.active[].id' <<<"${swarm_json}")

completed_ids=()
while IFS= read -r line; do
  [[ -z "${line}" ]] && continue
  completed_ids+=("${line}")
done < <(jq -r '.completed[].id' <<<"${swarm_json}")

blocked_ids=()
while IFS= read -r line; do
  [[ -z "${line}" ]] && continue
  blocked_ids+=("${line}")
done < <(jq -r '.blocked[].id' <<<"${swarm_json}")

candidate_lines=()
for id in "${ready_ids[@]+"${ready_ids[@]}"}"; do
  item="$(jq -r --arg id "${id}" '.[] | select(.id == $id) | [(.priority // 99), (.dependent_count // 0), .title, (.labels | join(","))] | @tsv' <<<"${list_json}")"
  priority="99"
  dependent="0"
  title=""
  labels=""
  if [[ -n "${item}" ]]; then
    IFS=$'\t' read -r priority dependent title labels <<<"${item}"
  fi
  checkpoint=0
  if [[ "${title}" =~ [Cc]heckpoint ]] || [[ "${title}" =~ [Ii]ntegration ]]; then
    checkpoint=1
  fi
  candidate_lines+=("${priority}\t${dependent}\t${checkpoint}\t${id}\t${labels}")
done

sorted_candidates=()
while IFS= read -r line; do
  [[ -z "${line}" ]] && continue
  sorted_candidates+=("${line}")
done < <(printf '%b\n' "${candidate_lines[@]+"${candidate_lines[@]}"}" | sort -t $'\t' -k1,1n -k2,2nr -k3,3nr -k4,4)

extract_lock_groups() {
  local labels="$1"
  local groups=""
  local -a labels_arr=()
  IFS=',' read -r -a labels_arr <<<"${labels}"
  for label in "${labels_arr[@]+"${labels_arr[@]}"}"; do
    if [[ "${label}" == mesh-lock:* ]]; then
      group="${label#mesh-lock:}"
      if [[ -z "${groups}" ]]; then
        groups="${group}"
      else
        groups="${groups} ${group}"
      fi
    fi
  done
  printf '%s\n' "${groups}"
}

select_wave() {
  local allow_checkpoints="$1"
  local used_groups=""
  local -a selected=()

  for line in "${sorted_candidates[@]+"${sorted_candidates[@]}"}"; do
    IFS=$'\t' read -r _priority _dependent _checkpoint id labels <<<"${line}"
    if [[ "${allow_checkpoints}" -eq 0 && "${_checkpoint}" -eq 1 ]]; then
      continue
    fi
    groups="$(extract_lock_groups "${labels}")"
    conflict=0
    for group in ${groups}; do
      if [[ " ${used_groups} " == *" ${group} "* ]]; then
        conflict=1
        break
      fi
    done
    if [[ ${conflict} -eq 1 ]]; then
      continue
    fi
    selected+=("${id}")
    for group in ${groups}; do
      if [[ " ${used_groups} " != *" ${group} "* ]]; then
        if [[ -z "${used_groups}" ]]; then
          used_groups="${group}"
        else
          used_groups="${used_groups} ${group}"
        fi
      fi
    done
    if [[ ${#selected[@]} -ge ${concurrency} ]]; then
      break
    fi
  done

  printf '%s\n' "${selected[@]+"${selected[@]}"}"
}

is_checkpoint_id() {
  local needle="$1"
  local line
  for line in "${candidate_lines[@]+"${candidate_lines[@]}"}"; do
    IFS=$'\t' read -r _priority _dependent _checkpoint id _labels <<<"${line}"
    if [[ "${id}" == "${needle}" ]]; then
      if [[ "${_checkpoint}" -eq 1 ]]; then
        return 0
      fi
      return 1
    fi
  done
  return 1
}

wave_contains_checkpoint() {
  local id
  for id in "$@"; do
    if is_checkpoint_id "${id}"; then
      return 0
    fi
  done
  return 1
}

selected_ids=()
while IFS= read -r line; do
  [[ -z "${line}" ]] && continue
  selected_ids+=("${line}")
done < <(select_wave 1)

format_list() {
  local arr=("$@")
  if [[ ${#arr[@]} -eq 0 ]]; then
    echo "(none)"
    return
  fi
  printf '%s' "${arr[0]}"
  local i
  for ((i=1; i<${#arr[@]}; i++)); do
    printf ', %s' "${arr[i]}"
  done
}

json_array() {
  if [[ $# -eq 0 ]]; then
    printf '[]'
    return 0
  fi
  printf '%s\n' "$@" | jq -R -s -c 'split("\n")[:-1]'
}

merge_slot_note=""
merge_slot_state="not-needed"

if wave_contains_checkpoint "${selected_ids[@]+"${selected_ids[@]}"}"; then
  merge_slot_state="required"
  if ! run_write_status "${mesh_merge_slot_script}" acquire; then
    merge_slot_state="busy"
    fallback_ids=()
    while IFS= read -r line; do
      [[ -z "${line}" ]] && continue
      fallback_ids+=("${line}")
    done < <(select_wave 0)

    if [[ ${#fallback_ids[@]} -gt 0 ]]; then
      selected_ids=("${fallback_ids[@]+"${fallback_ids[@]}"}")
      merge_slot_note="merge slot busy; checkpoint wave deferred"
    else
      selected_ids=()
      merge_slot_note="merge slot busy; no non-checkpoint work ready"
    fi
  else
    merge_slot_state="acquired"
    run_write "${mesh_merge_slot_script}" release
  fi
fi

build_prompt() {
  local bead_id="$1"
  local bead_context="$2"

  cat <<EOF
Work bead ${bead_id}. Use skill work.
Context:
${bead_context}
Do NOT run bd directly in this workspace; use ${mesh_bd_ro_hint} for read-only if needed.
If bead reads fail due to a stale DB, retry with BD_NO_DB=1 ${mesh_bd_ro_hint} (read-only, JSONL-backed).
Do not write/update beads from this workspace; if bead updates are required, ask via HUMAN_INPUT_REQUIRED.
Use the jujutsu skill for all VCS operations. Open a PR when done.
Restate done-means + acceptance criteria. Keep diffs bead-scoped.
If blocked, state why and what is needed.
If you must pause for follow-up, print a clear block:
HUMAN_INPUT_REQUIRED:
<question>
END_HUMAN_INPUT_REQUIRED

Final output block (required):
PR: <url>
Verify: <command>  # <pass/fail>
Changed: <paths>
Blockers: <none|details>
EOF
}

dispatch_wave() {
  local -a wave_ids=("$@")
  if [[ ${#wave_ids[@]} -eq 0 ]]; then
    return 0
  fi

  if [[ ! -x "${cx_exec_script}" ]]; then
    mesh_die "mesh-run: cx exec script not found: ${cx_exec_script}"
  fi

  if ! [[ "${agent_start}" =~ ^[0-9]+$ ]]; then
    usage_error "mesh-run: MESH_AGENT_START must be an integer"
  fi

  run_write "${mesh_agent_pool_script}" ensure --count "${#wave_ids[@]}" --prefix "${agent_prefix}" --start "${agent_start}"
  mesh_cleanup_stale_hooks "${stale_hook_ttl_seconds}"

  local idx=0
  local id
  for id in "${wave_ids[@]+"${wave_ids[@]}"}"; do
    local agent_name="${agent_prefix}$((agent_start + idx))"
    local slug
    slug="$(mesh_workspace_slug "${id}")"
    local workspace_path
    workspace_path="$(mesh_workspace_path "${id}")"

    run_write "${mesh_workspace_script}" create --backend "${workspace_backend}" --path "${workspace_path}" --branch "${slug}" "${id}"

    if [[ "${mesh_preflight}" -eq 1 ]]; then
      if [[ "${mesh_preflight_sync}" -eq 1 ]]; then
        if ! run_write_in_dir "${workspace_path}" bd --sandbox sync --import-only >/dev/null 2>&1; then
          mesh_audit_tool "mesh-run.preflight" \
            "$(jq -c -n --arg bead "${id}" --arg workspace "${workspace_path}" '{bead:$bead,workspace:$workspace}')" \
            '{"ok":false,"error":"bd sync --import-only failed"}'
          mesh_die "mesh-run: preflight sync failed for ${id}"
        fi
      fi
      if ! run_write_in_dir "${workspace_path}" "${mesh_bd_ro_hint}" show "${id}" --json >/dev/null 2>&1; then
        mesh_audit_tool "mesh-run.preflight" \
          "$(jq -c -n --arg bead "${id}" --arg workspace "${workspace_path}" '{bead:$bead,workspace:$workspace}')" \
          '{"ok":false,"error":"mesh-bd-ro show failed (db out of sync)"}'
        mesh_die "mesh-run: preflight failed for ${id}; bd DB out of sync in workspace"
      fi
    fi

    run_write "${mesh_agent_pool_script}" acquire "${agent_name}" "${id}"

    local bead_context=""
    run_read_capture bead_context bd show "${id}"
    local prompt
    prompt="$(build_prompt "${id}" "${bead_context}")"

    mesh_audit_prompt "${id}" "${agent_model}" "${prompt}"
    local -a cx_env=()
    if [[ "${MESH_BD_ALLOW_STALE:-0}" == "1" ]]; then
      cx_env=(env MESH_BD_ALLOW_STALE=1)
    fi

    if [[ -n "${mesh_run_log_dir}" ]]; then
      local log_dir="${mesh_run_log_dir}/${id}"
      local run_id
      run_id="$(date -u +%Y%m%dT%H%M%SZ)"
      run_write mkdir -p "${log_dir}"
      local log_file="${log_dir}/${run_id}.log"
      if [[ ${#cx_env[@]} -gt 0 ]]; then
        run_write_in_dir_logged "${workspace_path}" "${log_file}" "${cx_env[@]}" "${cx_exec_script}" "${prompt}"
      else
        run_write_in_dir_logged "${workspace_path}" "${log_file}" "${cx_exec_script}" "${prompt}"
      fi
    else
      if [[ ${#cx_env[@]} -gt 0 ]]; then
        run_write_in_dir "${workspace_path}" "${cx_env[@]}" "${cx_exec_script}" "${prompt}"
      else
        run_write_in_dir "${workspace_path}" "${cx_exec_script}" "${prompt}"
      fi
    fi

    idx=$((idx + 1))
  done
}

if [[ ${MESH_JSON} -eq 1 ]]; then
  commands_json="$(json_array "${DRY_RUN_COMMANDS[@]+"${DRY_RUN_COMMANDS[@]}"}")"
  dry_run_json="false"
  if [[ ${MESH_DRY_RUN} -eq 1 ]]; then
    dry_run_json="true"
  fi
  jq -n \
    --arg target_id "${target_id}" \
    --arg target_kind "${target_kind}" \
    --arg epic_id "${epic_id}" \
    --arg mesh_run_id "${mesh_run_id}" \
    --argjson concurrency "${concurrency}" \
    --argjson dry_run "${dry_run_json}" \
    --argjson commands "${commands_json}" \
    --argjson ready "$(json_array "${ready_ids[@]+"${ready_ids[@]}"}")" \
    --argjson active "$(json_array "${active_ids[@]+"${active_ids[@]}"}")" \
    --argjson blocked "$(json_array "${blocked_ids[@]+"${blocked_ids[@]}"}")" \
    --argjson completed "$(json_array "${completed_ids[@]+"${completed_ids[@]}"}")" \
    --argjson wave "$(json_array "${selected_ids[@]+"${selected_ids[@]}"}")" \
    '{ok:true,dry_run:$dry_run,commands:$commands,target_id:$target_id,target_kind:$target_kind,epic_id:$epic_id,mesh_run_id:$mesh_run_id,concurrency:$concurrency,ready:$ready,active:$active,blocked:$blocked,completed:$completed,recommended_wave:$wave}'
  exit 0
fi

ready_json="$(json_array "${ready_ids[@]+"${ready_ids[@]}"}")"
active_json="$(json_array "${active_ids[@]+"${active_ids[@]}"}")"
blocked_json="$(json_array "${blocked_ids[@]+"${blocked_ids[@]}"}")"
completed_json="$(json_array "${completed_ids[@]+"${completed_ids[@]}"}")"
selected_json="$(json_array "${selected_ids[@]+"${selected_ids[@]}"}")"

wave_input="$(jq -c -n \
  --arg target_id "${target_id}" \
  --arg epic_id "${epic_id}" \
  --argjson concurrency "${concurrency}" \
  --argjson ready "${ready_json}" \
  --argjson active "${active_json}" \
  --argjson blocked "${blocked_json}" \
  --argjson completed "${completed_json}" \
  '{target_id:$target_id,epic_id:$epic_id,concurrency:$concurrency,ready:$ready,active:$active,blocked:$blocked,completed:$completed}')"

wave_output="$(jq -c -n \
  --argjson wave "${selected_json}" \
  --arg merge_slot_state "${merge_slot_state}" \
  --arg merge_slot_note "${merge_slot_note}" \
  '{recommended_wave:$wave,merge_slot_state:$merge_slot_state,merge_slot_note:$merge_slot_note}')"

mesh_audit_tool "mesh-run.wave" "${wave_input}" "${wave_output}"
dispatch_wave "${selected_ids[@]+"${selected_ids[@]}"}"

if [[ ${MESH_DRY_RUN} -eq 1 ]]; then
  for cmd in "${DRY_RUN_COMMANDS[@]+"${DRY_RUN_COMMANDS[@]}"}"; do
    mesh_emit "dry-run: ${cmd}"
  done
  exit 0
fi

echo "mesh-run: target=${target_id} (kind: ${target_kind})"
echo "mesh-run: concurrency=${concurrency}"
if [[ -n "${mesh_run_id}" ]]; then
  echo "mesh-run: mol=${mesh_run_id}"
fi
echo ""
echo "Wave status"
echo "- Ready: $(format_list "${ready_ids[@]+"${ready_ids[@]}"}")"
echo "- Blocked: $(format_list "${blocked_ids[@]+"${blocked_ids[@]}"}")"
echo "- Active: $(format_list "${active_ids[@]+"${active_ids[@]}"}")"
echo "- Completed: $(format_list "${completed_ids[@]+"${completed_ids[@]}"}")"
echo "- Recommended wave: $(format_list "${selected_ids[@]+"${selected_ids[@]}"}")"
echo "- Merge slot: ${merge_slot_state}"
if [[ -n "${merge_slot_note}" ]]; then
  echo "- Note: ${merge_slot_note}"
fi
echo ""
echo "Output legend"
echo "- Importing from JSONL...: bd refreshed local DB from JSONL (no data changes implies clean sync)"
echo "- int-<id>: mesh audit/run identifier for this action"
echo "- ensure: agent beads created or confirmed"
echo "- workspace exists/created: workspace path ready for the bead"
echo "- Set <agent>.hook: agent hooked to work bead; state=working means assigned"
echo "- acquire: agent claimed for this run"
