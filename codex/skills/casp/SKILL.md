---
name: casp
description: Run a Node JSONL proxy that spawns `codex app-server` and exposes an orchestration-friendly stream API. Use to control Codex programmatically (many threads/turns), auto-handle approvals, forward tool calls, and mine sessions via `thread/*` APIs using schemas generated by your installed `codex`.
---

# casp (Codex App-Server Protocol)

## Overview

Casp ships a small Node proxy (`scripts/casp_proxy.mjs`) that:

- Spawns `codex app-server`.
- Performs the required handshake (`initialize` -> `initialized`) with `experimentalApi: true`.
- Reads/writes JSONL over stdio.
- Auto-accepts approvals.
- Forwards server-initiated tool requests to the orchestrator and blocks until a response arrives.
- Emits a lossless, orchestration-friendly event stream (includes the raw app-server message plus derived routing keys).

This skill assumes `codex` is available on PATH and does not require access to any repo source tree.

## Workflow

1. Start the proxy.
   - Run `node scripts/casp_proxy.mjs` from the casp skill directory (example: `node ~/.dotfiles/codex/skills/casp/scripts/casp_proxy.mjs`).
   - Optional: pass `--cwd /path/to/workspace` to control where `codex app-server` runs and where `.casp/state.json` is written.
   - Wait for a `casp/ready` event.

2. Drive Codex by sending requests to the proxy.
   - Send `casp/request` messages (method + params) to proxy stdin.
   - Proxy assigns request ids (unless you supply one), forwards to app-server, and emits `casp/fromServer` responses.

3. Stream and route notifications.
   - Consume `casp/fromServer` events and route by `threadId` / `turnId` / `itemId`.
   - Treat the proxy stream as the source of truth; the raw wire message is always included under `msg`.

4. Handle forwarded server requests.
   - Only reply when casp emits `casp/serverRequest` (these are the server requests casp did not auto-handle).
   - Respond with `casp/respond` using the same `id`.
   - Approvals are auto-accepted (including best-effort execpolicy amendments) and will not block you.

5. Mine sessions (optional).
   - Use `thread/list` and `thread/read` (optionally `includeTurns:true`) to build your own index.
   - The server is not a search engine; extract data and index externally.

## Dynamic Tools (Optional)

If you opt into dynamic tools, register them on `thread/start` via `dynamicTools` (experimental API surface).
When the server emits `casp/serverRequest` with `method: "item/tool/call"`, run the tool in your orchestrator and reply with `casp/respond`.

## Proxy Protocol (stdin/stdout)

The proxy itself speaks JSONL over stdio.

### stdin -> casp

- `casp/request` sends a JSON-RPC request to `codex app-server`:

```json
{
  "type": "casp/request",
  "clientRequestId": "any-string",
  "method": "thread/start",
  "params": { "cwd": "/path", "experimentalRawEvents": false }
}
```

- `casp/respond` answers a server-initiated request forwarded by casp:

```json
{
  "type": "casp/respond",
  "id": 123,
  "result": {
    "contentItems": [{ "type": "inputText", "text": "..." }],
    "success": true
  }
}
```

- `casp/state/get` emits the current proxy state.
- `casp/stats/get` emits a stats snapshot (uptime, queue depth, counts).
- `casp/exit` shuts down the proxy.

### stdout <- casp

- `casp/ready` indicates the proxy finished handshake.
- `casp/fromServer` is emitted for every JSON message from `codex app-server`.
- `casp/toServer` is emitted for every JSON message sent to `codex app-server` (includes auto-approvals and handshake).
- `casp/serverRequest` is emitted for server-initiated requests that require an orchestrator response (tool calls, auth refresh, etc.).
- `casp/stats` and `casp/ioPaused`/`casp/ioResumed` help you monitor backpressure.

All events include:

- `seq` (monotonic)
- `ts` (ms since epoch)
- `sessionId` (unique per proxy instance)
- derived keys `threadId` / `turnId` / `itemId` when present
- `msg` (the raw app-server message; lossless)

## Canonical Schema Source

Use your installed `codex` binary to generate schemas that match your version:

```sh
codex app-server generate-ts --out DIR
codex app-server generate-json-schema --out DIR

# If you need experimental methods/fields (e.g. dynamic tools), include:
codex app-server generate-ts --experimental --out DIR
codex app-server generate-json-schema --experimental --out DIR
```

## Local References

Read `references/codex_app_server_protocol.md` for a protocol map and the recommended routing/response strategy.

## Resources

### references/

Protocol notes for fast lookup during implementation.

### scripts/

Runnable Node proxy for orchestration.

Included:
- `scripts/casp_proxy.mjs` (the proxy)
- `scripts/casp_client.mjs` (JS wrapper: spawn proxy + request() + event stream)
- `scripts/casp_example_orchestrator.mjs` (example orchestration script)
